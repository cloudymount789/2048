<!DOCTYPE html>
<html lang="zh"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SICP_scheme_笔记</title>
    <meta charset="utf-8">
    <meta name="description" content="Ladder@摘要
本文为《计算机程序的构造和解释》（SICP，CS61A 南大引进版）scheme部分课程核心笔记，聚焦程序设计的底层逻辑与核心思想，旨在帮助学习者搭建“知其然更知其所以然”的编程认知框架。适合正在学习 CS61A 课程的学习者梳理知识体系，也可作为编程入门者夯实基础、理解程序设计本质的参考资料。">
    <meta name="author" content="CloudyMount">
    <link rel="canonical" href="https://cloudymount789.github.io/blog/sicp_note_scheme/">

    <link rel="alternate" type="application/rss+xml" href="https://cloudymount789.github.io//index.xml" title="CloudyMount">

    


    <meta property="og:url" content="https://cloudymount789.github.io/blog/sicp_note_scheme/">
  <meta property="og:site_name" content="CloudyMount">
  <meta property="og:title" content="SICP_scheme_笔记">
  <meta property="og:description" content="摘要
本文为《计算机程序的构造和解释》（SICP，CS61A 南大引进版）scheme部分课程核心笔记，聚焦程序设计的底层逻辑与核心思想，旨在帮助学习者搭建“知其然更知其所以然”的编程认知框架。适合正在学习 CS61A 课程的学习者梳理知识体系，也可作为编程入门者夯实基础、理解程序设计本质的参考资料。">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2026-01-03T12:47:38+08:00">
    <meta property="article:modified_time" content="2026-01-03T12:47:38+08:00">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="SICP_scheme_笔记">
  <meta name="twitter:description" content="摘要
本文为《计算机程序的构造和解释》（SICP，CS61A 南大引进版）scheme部分课程核心笔记，聚焦程序设计的底层逻辑与核心思想，旨在帮助学习者搭建“知其然更知其所以然”的编程认知框架。适合正在学习 CS61A 课程的学习者梳理知识体系，也可作为编程入门者夯实基础、理解程序设计本质的参考资料。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "https://cloudymount789.github.io/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "SICP_scheme_笔记",
      "item": "https://cloudymount789.github.io/blog/sicp_note_scheme/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SICP_scheme_笔记",
  "name": "SICP_scheme_笔记",
  "description": "摘要\n本文为《计算机程序的构造和解释》（SICP，CS61A 南大引进版）scheme部分课程核心笔记，聚焦程序设计的底层逻辑与核心思想，旨在帮助学习者搭建“知其然更知其所以然”的编程认知框架。适合正在学习 CS61A 课程的学习者梳理知识体系，也可作为编程入门者夯实基础、理解程序设计本质的参考资料。\n",
  "keywords": [
    
  ],
  "articleBody": "摘要\n本文为《计算机程序的构造和解释》（SICP，CS61A 南大引进版）scheme部分课程核心笔记，聚焦程序设计的底层逻辑与核心思想，旨在帮助学习者搭建“知其然更知其所以然”的编程认知框架。适合正在学习 CS61A 课程的学习者梳理知识体系，也可作为编程入门者夯实基础、理解程序设计本质的参考资料。\nSICP Note -\u003e Scheme 主题一：Scheme 基础与求值 (Scheme Basics and Evaluation) 主题概述 Scheme 是一种 Lisp 方言，其核心特点是程序由表达式 (Expressions) 构成，并且代码与数据结构高度统一。理解 Scheme 的求值规则，尤其是调用表达式 (Call Expressions) 和特殊形式 (Special Forms) 的区别，是关键。\n核心概念 1. 表达式的分类 (Types of Expressions) Scheme 程序由两种表达式构成 ：\n原子表达式 (Atomic Expressions / Atoms) ：不可再分割的基本值。 自求值 (Self-evaluating): 数字 (3, -10)、布尔值 (#t, #f) 。 符号 (Symbols): 绑定到值的名称 (+, modulo, x) 。 组合 (Combinations) ：形如 ( ...) 。它们是调用表达式或特殊形式表达式 。 2. 调用表达式求值 (Call Expression Evaluation) 调用表达式将一个过程 (Procedure) 应用于一组参数 (Arguments) 。\n求值三步法:\n对 运算符 (Operator) 求值，得到一个过程 。 从左到右对所有 操作数 (Operands) 求值，得到参数 。 将过程应用于参数 。 例： scm\u003e (- (+ 7 (* 4 6)) (* 3 5)) ; 1. (* 4 6) -\u003e 24 ; 2. (+ 7 24) -\u003e 31 ; 3. (* 3 5) -\u003e 15 ; 4. (- 31 15) -\u003e 16 16 3. 特殊形式 (Special Forms) 特殊形式的求值规则不同于标准的调用表达式，它们的运算符（如 define, if, lambda）不一定先求值，且操作数不一定全部求值 。\n特殊形式 英文标注 语法 求值规则 定义 define (define ) 1. 求值 。 2. 将结果值绑定到当前框架的 上 。 条件 if (if ) 1. 求值 。 2. 如果结果不是 #f (唯一 Falsy 值) ，求值并返回 ；否则求值并返回 。 过程 lambda (lambda () ) 创建并返回一个 lambda 过程 (Procedure) 。不求值函数体 ，函数体在过程被调用时才求值 。 define 简化形式 (Function Shorthand): (define (square x) (* x x)) 等同于 (define square (lambda (x) (* x x))) 。 主题二：数据抽象：Pairs 与 Lists (Data Abstraction: Pairs and Lists) 主题概述 Scheme 中唯一的序列类型是链表 (Linked List) 。链表是通过基本的构建块对 (Pairs) 构成的 。\n核心概念 (Core Concepts) 1. 对 (Pairs) 对是使用 cons 表达式创建的基本结构。\ncons: 构造一个对 。 (cons ) car: 选择对中的第一个元素 (Head) 。 cdr: 选择对中的第二个元素 (Tail) 。 2. 链表 (Linked Lists) 链表是通过递归地使用 cons 构造对，并以特殊符号 nil (空列表) 终止而形成的序列结构。\nnil: 表示空列表 (Empty List) 。\n链表结构：第二个元素 (cdr) 必须是另一个对或 nil 。\n例题：链表构造\nscm\u003e (cons 1 (cons 2 nil)) (1 2) ; 列表的表示形式 scm\u003e (define x (cons 1 (cons 2 nil))) scm\u003e (car x) 1 scm\u003e (cdr x) (2) ; 结果仍然是一个列表 (一个对，其 car 是 2，cdr 是 nil) 主题三：符号编程与引用 (Symbolic Programming and Quotation) 主题概述 在 Scheme 中，符号 (Symbols) 通常求值为其绑定的值。引用 (Quotation) 允许我们直接引用符号本身，而不是它的值 。这对于将 Scheme 代码结构作为数据处理（符号编程）至关重要。\n核心概念 (Core Concepts) 1. 引用 (quote 或 ') 作用: 阻止表达式被求值，而是将表达式本身作为值返回 。\n使用方式:\n长形式: (quote ) 短形式: ' 例题：引用符号\nscm\u003e (define a 1) scm\u003e (list a 2) (1 2) ; a 被求值为 1 scm\u003e (list 'a 2) (a 2) ; 'a 被引用，求值为符号 a 本身 2. 引用组合 (Quoting Combinations) 引用也可以应用于组合表达式，使其成为一个列表数据结构。\n例题：引用列表 scm\u003e '(a b c) (a b c) ; 返回列表 (a b c) scm\u003e (car '(a b c)) a ; car 选择列表的第一个元素 scm\u003e (cdr '(a b c)) (b c) ; cdr 选择列表的剩余部分 主题四：尾递归 (Tail Recursion) 主题概述 Scheme 语言不内置迭代 (Iteration) 结构，循环通常通过递归 (Recursion) 实现 。尾递归 (Tail Recursion) 是一种特殊的递归形式，支持尾调用优化 (Tail Call Optimization)，能像迭代一样高效运行，使用常数 (Constant) 数量的帧 (Frames) 。\n核心概念 1. 尾上下文与尾调用 (Tail Context and Tail Call) 尾上下文 (Tail Context): 表达式在尾上下文中，意味着它是在函数调用中求值的最后一步。在它求值/应用之后，没有其他操作会进行 。 尾调用 (Tail Call): 发生在尾上下文中的函数调用 。 尾递归 (Tail Recursion): 尾调用调用了函数自身 。 2. 尾调用优化 (Tail Call Optimization, TCO) 如果 Scheme 语言支持 TCO，一个尾递归函数只会开启常数数量的帧，从而避免栈溢出，效率等同于迭代。 3. 识别尾上下文 (Identifying Tail Contexts) 是尾上下文 (Tail Contexts):\nlambda（函数）的最后一个 body 子表达式。 if 中的 和 (前提是 if 表达式本身在尾上下文中)。 and, or, begin, let 中的最后一个子表达式。 不是尾上下文 (Non-Tail Contexts):\n在 *, +, - 等操作符下作为操作数 (Operand) 的递归调用。因为操作数求值后，还需要进行操作符的运算。 例题：非尾递归阶乘 (Non-Tail Recursive Factorial)\n(define (fact n) (if (= n 0) 1 # 递归调用 (fact (- n 1)) 的结果必须和 n 相乘 # 因此 (fact ...) 不在尾上下文，需要保留帧 f1, f2, ... (* n (fact (- n 1))))) 4. 编写尾递归函数 (Writing Tail Recursive Functions) 要将非尾递归函数转换为尾递归，通常需要引入一个辅助函数 (Helper Function) 和一个累加器 (Accumulator) 参数。\n目标: 将所有等待的计算（例如上面的 * n）作为参数，传递给下一次递归调用。\n累加器 (Accumulator): 存储到目前为止的计算结果。\n例题：尾递归阶乘 (Tail Recursive Factorial)\n(define (fact n) # 引入辅助函数 fact-tail (define (fact-tail n result) ; result 就是累加器 (if (\u003c= n 1) result # 最后一步操作是 (fact-tail ...)， # 这是一个尾调用，无需保留当前帧。 (fact-tail (- n 1) (* n result)))) (fact-tail n 1)) # 初始调用，累加器从 1 开始 主题五：表达式作为数据 (Expressions As Data) 主题概述 Scheme 的核心理念是代码即数据 (Code as Data)。由于 Scheme 表达式（组合）本身就是列表，我们可以将代码结构当作普通数据来操作。\n核心概念 1. 表达式的表示与求值 (Representation and Evaluation) 表达式的类型: 在 Scheme 中，表达式要么是原始表达式 (primitive expressions)，要么是列表 (lists)。 引用 (Quoting): ‘ 或 (quote ) 阻止表达式求值，返回表达式本身（即一个数据结构）。 eval 函数: 接收一个未求值 (unevaluated) 的表达式（数据），并对其进行求值。 例题: scm\u003e '(+ 1 2) ; 引用，返回列表数据 (+ 1 2) scm\u003e (eval '(+ 1 2)) ; 对该列表进行求值 3 表达式的操作: 我们可以将表达式赋值给变量、作为参数传递给函数、甚至在函数内创建并返回新的表达式。 主题六：辅助特殊形式 (Auxiliary Special Forms) 主题概述 begin 和 let 是 Scheme 中常用的特殊形式，用于控制求值顺序和局部变量的创建。\n核心概念 1. begin (顺序执行) 作用: begin 接收任意数量的子表达式。它会按顺序 (in order) 求值这些子表达式，并以最后一个子表达式的值作为整个 begin 表达式的值。 用途: 当你需要在一个预期只有一个表达式的位置（如函数体）执行多个带有副作用的操作时，begin 非常有用。 例题: scm\u003e (begin (define x 2) (define x (+ x 1)) x) 3 ; 返回最后一个表达式 x 的值 2. let (局部绑定) 作用: let 用于创建临时的局部变量绑定，仅在 let 的主体 (body) 中有效。 绑定规则: 所有的 symbol 都与其对应的 expr 的值并行 (in parallel) 绑定。这意味着一个绑定不能引用同一 let 表达式中定义的其他绑定。 语法: (let ((symbol1 expr1) (symbol2 expr2) ...) ) 主题七：宏原理 (Macro Principles) 主题概述 宏 (Macros) 是一种元编程 (Metaprogramming) 工具，它允许用户在程序求值之前转换程序的代码结构，从而扩展语言的语法。\n核心概念 1. 定义宏 (define-macro) 语法: (define-macro ( ) )。 宏与过程的区别: 过程 (Procedure): 接收值 (values) 作为参数，返回值。 宏 (Macro): 接收表达式 (expressions) 作为参数，返回表达式（代码）。 2. 宏的求值流程 (Macro Evaluation) 【核心考点】 宏调用的求值流程有别于普通函数调用：\n不求值操作数 (Operands Not Evaluated): 宏的操作数不会像普通函数调用那样被求值。 传递表达式: 操作数（表达式本身）作为参数传递给宏过程。 宏转换: 宏过程执行，返回一个新的表达式 (a new expression)。 再次求值: 解释器会立即对宏返回的新表达式进行求值 (evaluated)。 3. 宏的用途 (Writing Macros) 编写宏时，关键是思考具有等效行为的表达式是什么。宏的目的是将自定义的语法转换为等效的 Scheme 基本语法。\n例题：for 宏: 转换 (for x in '(1 2 3 4) do (* x x)) 为 (map (lambda (x) (* x x)) '(1 2 3 4))。 (define-macro (for sym in vals do expr) (list 'map (list 'lambda (list sym) expr) vals)) 主题八：准引用 (Quasi-Quotation) 主题概述 在宏中，我们经常需要构造新的列表（表达式）。准引用 (Quasi-Quotation) 允许在引用 (Quoting) 表达式的同时，有选择地对其中的部分子表达式进行求值，大大简化了代码生成。\n核心概念 符号 英文标注 名称 作用 ``` Quasiquote 准引用 允许列表中的大部分内容被视为字面值（像 quote 一样）。 , Unquote 取消引用 必须出现在准引用 ```` 内部。紧跟其后的表达式会被求值，然后将其值插入到构造的列表中。 例题：使用准引用重写 for 宏 (define-macro (for sym vals expr) ; 整个结构是准引用的 (`)，大部分是字面值 ; ,sym, ,expr, ,vals 在宏应用时会被求值并替换到相应位置 `(map (lambda (,sym) ,expr) ,vals)) ( 和 map 是字面符号。 ,sym 求值结果是符号 x，被插入到 lambda 的参数列表中。 ,expr 求值结果是表达式 (* x x)，被插入到 lambda 的函数体中。 ,vals 求值结果是表达式 '(1 2 3 4)，被插入到 map 的第二个参数位置。 函数1:twice 方式1:正常函数 scm\u003e (define (twice exp) (list 'begin exp exp)) twice scm\u003e (eval (twice '(print 2))) 2 2 方式2:macro scm\u003e (define-macro (twice exp) (list 'begin exp exp)) twice scm\u003e (twice (print 2)) 2 2 即macro只是相当于省略了调用时需要的eval 和' 方式3:准引用(suger) scm\u003e (define-macro (twice exp) `(begin ,exp ,exp)) twice scm\u003e (twice (print 2)) 2 2 函数2 scm\u003e (define-macro (add-to sym exp) (list 'define sym (list '+ sym exp))) add-to scm\u003e (add-to 'x (+ x 2)) x scm\u003e x 30 scm\u003e (define-macro (add-to sym exp) `(define ,sym (+ ,sym ,exp))) add-to scm\u003e (add-to x (+ x 2)) x scm\u003e x 62 函数3 scm\u003e (define-macro (for sym in val do exp) `(map (lambda (,sym) ,exp) ,val)) for scm\u003e (for i in (list 1 2 3) do (print i)) 1 2 3 (undefined undefined undefined) (上面这行是map的返回值,即None,None,None) 主题九：惰性求值与流基础 (Lazy Evaluation \u0026 Stream Basics) 主题概述 流 (Streams) 是 Scheme 中处理序列的一种方式。它与链表（List）非常相似，但核心区别在于：流的“剩余部分”（tail）只有在被显式要求时才会进行计算。这种机制被称为惰性求值 (Lazy Evaluation)。\n核心概念 1. 为什么需要流？ Python 对比: Python 使用迭代器（Iterators）和生成器（Generators）来实现惰性求值，可以表示无限序列。 Scheme 链表的局限: 在标准链表中，cons 的第二个参数总是会被立即求值。如果尝试递归定义无限链表，会导致 maximum recursion depth exceeded（达到最大递归深度）。 流的优势: 流允许我们表示巨大的甚至无限长 (infinitely long) 的列表，因为它只在需要时计算下一个元素。 2. 流的构造与基本操作 cons-stream: 构造一个流。其第二个参数是一个承诺 (Promise)，不会立即求值。 car: 获取流的第一个元素（与 List 相同）。 cdr-stream: 获取流的剩余部分。这是关键操作：它会强制 (Force) 履行承诺，计算并返回流的下一个部分。 例题：流的表示 scm\u003e (define s (cons-stream 1 (cons-stream 2 nil))) s scm\u003e s (1 . #[promise (not forced)]) ; 第二部分显示为尚未强制的承诺 scm\u003e (car s) 1 scm\u003e (cdr-stream s) (2 . #[promise (not forced)]) 主题十一：无限流 (Infinite Streams) 主题概述 由于流是惰性求值的，我们可以定义一个在逻辑上永远不会结束的序列。\n核心概念 1. 定义无限流 通过在 cons-stream 的第二个参数中进行递归调用，可以创建一个无限序列。\n例题：整数流 (Integer Stream) (define (ints first) (cons-stream first (ints (+ first 1)))) scm\u003e (define s (ints 1)) scm\u003e (car s) 1 scm\u003e (car (cdr-stream s)) 2 2. 使用高阶函数操作流 我们可以像操作 List 一样编写流的操作函数，只需将 cons 替换为 cons-stream，将 cdr 替换为 cdr-stream。\nmap-stream (流映射): (define (map-stream fn s) (if (null? s) nil (cons-stream (fn (car s)) (map-stream fn (cdr-stream s))))) filter-stream (流过滤): 只有当满足条件的元素被找到时，才会构造流的下一个 car。 主题十二：流的高级应用 (Advanced Stream Applications) 核心概念 (Core Concepts) 1. 递归定义的流 (Self-referencing Streams) 流可以引用自身来定义复杂的序列。\n全 1 流 (Ones): (define ones (cons-stream 1 ones)) 整数流 (Integers): 通过将“全 1 流”与“当前整数流”相加得到下一个整数。 (define ones (cons-stream 1 ones)) (define ints (cons-stream 1 (add-stream ones ints))) 2. 流与列表的转换 stream-to-list: 为了查看流的内容，通常需要将其转换为列表，并指定获取元素的数量（避免死循环）。 ",
  "wordCount" : "1201",
  "inLanguage": "zh",
  "datePublished": "2026-01-03T12:47:38+08:00",
  "dateModified": "2026-01-03T12:47:38+08:00",
  "author":{
    "@type": "Person",
    "name": "CloudyMount"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cloudymount789.github.io/blog/sicp_note_scheme/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "CloudyMount",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cloudymount789.github.io/favicon.ico"
    }
  }
}
</script>
    <link rel="icon" href="/images/LittleElysia.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/LittleElysia.png">

<link rel="manifest" href="/images/LittleElysia.png">
    

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css" />

    
    
    <link rel="stylesheet" href="/css/main.min.ec28f09e946fc0df77c187fcd0d0ebde58fca6de8efb8e1620f3d45c32d4da88.css" integrity="sha256-7CjwnpRvwN93wYf80NDr3lj8pt6O&#43;44WIPPUXDLU2og=" crossorigin="anonymous" media="screen" />

    
    <link rel="stylesheet" href="/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css" />

    
    <script src="/js/highlight.min.min.04ed3315a5c3f66e19fbfc8c933577697fe73787c63333adc024c4fabed580bc.js"></script>
    <script>hljs.highlightAll();</script>

    <script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script>
    </head>
<body>
      <main class="wrapper"><nav class="navigation">
    <section class="container">
        <a class="navigation-brand" href="/">
            主页
        </a>
        <input type="checkbox" id="menu-toggle" />
        <label class="menu-button float-right" for="menu-toggle">
            <span></span><span></span><span></span>
        </label>
        
        <ul class="navigation-list" id="navigation-list">
            
            
            <li class="navigation-item navigation-menu">
                <a class="navigation-link" href="/blog/">文章</a>
            </li>
            
            <li class="navigation-item navigation-menu">
                <a class="navigation-link" href="/archive/">归档</a>
            </li>
            
            <li class="navigation-item navigation-menu">
                <a class="navigation-link" href="/contact/">联系</a>
            </li>
            
            <li class="navigation-item navigation-menu">
                <a class="navigation-link" href="/xx/">网站统计</a>
            </li>
            
            

            <li class="navigation-item menu-separator">
                <span>|</span>
            </li>

            
            
            <li class="navigation-item navigation-social">
                <a class="navigation-link" href="https://github.com/cloudymount789"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a>
            </li>
            
            <li class="navigation-item navigation-social">
                <a class="navigation-link" href="https://space.bilibili.com/1369055152?spm_id_from=333.1007.0.0"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tv"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline></svg></a>
            </li>
            
            

            <li class="navigation-item navigation-dark">
                <button id="mode" type="button" aria-label="toggle user light or dark theme">
                    <span class="toggle-dark"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></span>
                    <span class="toggle-light"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></span>
                </button>
            </li>

            
        </ul>
        
    </section>
</nav>
<div id="content">
<article class="blog-single">
  <header class="blog-title">
    <h1>SICP_scheme_笔记</h1>
  </header>

  <p>
  <small>
    2026年1月3日&nbsp;· 1201 字&nbsp;· 6 分钟</small>

  
<p>

  <div class="blog-toc">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#主题一scheme-基础与求值-scheme-basics-and-evaluation">主题一：Scheme 基础与求值 (Scheme Basics and Evaluation)</a>
      <ul>
        <li><a href="#主题概述">主题概述</a></li>
        <li><a href="#核心概念">核心概念</a></li>
      </ul>
    </li>
    <li><a href="#主题二数据抽象pairs-与-lists-data-abstraction-pairs-and-lists">主题二：数据抽象：Pairs 与 Lists (Data Abstraction: Pairs and Lists)</a>
      <ul>
        <li><a href="#主题概述-1">主题概述</a></li>
        <li><a href="#核心概念-core-concepts">核心概念 (Core Concepts)</a></li>
      </ul>
    </li>
    <li><a href="#主题三符号编程与引用-symbolic-programming-and-quotation">主题三：符号编程与引用 (Symbolic Programming and Quotation)</a>
      <ul>
        <li><a href="#主题概述-2">主题概述</a></li>
        <li><a href="#核心概念-core-concepts-1">核心概念 (Core Concepts)</a></li>
      </ul>
    </li>
    <li><a href="#主题四尾递归-tail-recursion">主题四：尾递归 (Tail Recursion)</a>
      <ul>
        <li><a href="#主题概述-3">主题概述</a></li>
        <li><a href="#核心概念-1">核心概念</a></li>
      </ul>
    </li>
    <li><a href="#主题五表达式作为数据-expressions-as-data">主题五：表达式作为数据 (Expressions As Data)</a>
      <ul>
        <li><a href="#主题概述-4">主题概述</a></li>
        <li><a href="#核心概念-2">核心概念</a></li>
      </ul>
    </li>
    <li><a href="#主题六辅助特殊形式-auxiliary-special-forms">主题六：辅助特殊形式 (Auxiliary Special Forms)</a>
      <ul>
        <li><a href="#主题概述-5">主题概述</a></li>
        <li><a href="#核心概念-3">核心概念</a></li>
      </ul>
    </li>
    <li><a href="#主题七宏原理-macro-principles">主题七：宏原理 (Macro Principles)</a>
      <ul>
        <li><a href="#主题概述-6">主题概述</a></li>
        <li><a href="#核心概念-4">核心概念</a></li>
      </ul>
    </li>
    <li><a href="#主题八准引用-quasi-quotation">主题八：准引用 (Quasi-Quotation)</a>
      <ul>
        <li><a href="#主题概述-7">主题概述</a></li>
        <li><a href="#核心概念-5">核心概念</a></li>
      </ul>
    </li>
    <li><a href="#主题九惰性求值与流基础-lazy-evaluation--stream-basics">主题九：惰性求值与流基础 (Lazy Evaluation &amp; Stream Basics)</a>
      <ul>
        <li><a href="#主题概述-8">主题概述</a></li>
        <li><a href="#核心概念-6">核心概念</a></li>
      </ul>
    </li>
    <li><a href="#主题十一无限流-infinite-streams">主题十一：无限流 (Infinite Streams)</a>
      <ul>
        <li><a href="#主题概述-9">主题概述</a></li>
        <li><a href="#核心概念-7">核心概念</a></li>
      </ul>
    </li>
    <li><a href="#主题十二流的高级应用-advanced-stream-applications">主题十二：流的高级应用 (Advanced Stream Applications)</a>
      <ul>
        <li><a href="#核心概念-core-concepts-2">核心概念 (Core Concepts)</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>

  <section class="blog-content"><p>摘要</p>
<p>本文为《计算机程序的构造和解释》（SICP，CS61A 南大引进版）scheme部分课程核心笔记，聚焦程序设计的底层逻辑与核心思想，旨在帮助学习者搭建“知其然更知其所以然”的编程认知框架。适合正在学习 CS61A 课程的学习者梳理知识体系，也可作为编程入门者夯实基础、理解程序设计本质的参考资料。</p>
<h1 id="sicp-note---scheme">SICP Note -&gt; Scheme</h1>
<h2 id="主题一scheme-基础与求值-scheme-basics-and-evaluation">主题一：Scheme 基础与求值 (Scheme Basics and Evaluation)</h2>
<h3 id="主题概述">主题概述</h3>
<p>Scheme 是一种 Lisp 方言，其核心特点是程序由<strong>表达式 (Expressions)</strong> 构成，并且代码与数据结构高度统一。理解 Scheme 的求值规则，尤其是<strong>调用表达式 (Call Expressions)</strong> 和<strong>特殊形式 (Special Forms)</strong> 的区别，是关键。</p>
<hr>
<h3 id="核心概念">核心概念</h3>
<h4 id="1-表达式的分类-types-of-expressions">1. 表达式的分类 (Types of Expressions)</h4>
<p>Scheme 程序由两种表达式构成 ：</p>
<ul>
<li><strong>原子表达式 (Atomic Expressions / Atoms)</strong> ：不可再分割的基本值。
<ul>
<li><strong>自求值 (Self-evaluating):</strong> 数字 (<code>3</code>, <code>-10</code>)、布尔值 (<code>#t</code>, <code>#f</code>) 。</li>
<li><strong>符号 (Symbols):</strong> 绑定到值的名称 (<code>+</code>, <code>modulo</code>, <code>x</code>) 。</li>
</ul>
</li>
<li><strong>组合 (Combinations)</strong>  ：形如 <code>(&lt;operator&gt; &lt;operand1&gt; &lt;operand2&gt; ...)</code>  。它们是<strong>调用表达式</strong>或<strong>特殊形式表达式</strong> 。</li>
</ul>
<h4 id="2-调用表达式求值-call-expression-evaluation">2. 调用表达式求值 (Call Expression Evaluation)</h4>
<p>调用表达式将一个过程 (Procedure) 应用于一组参数 (Arguments) 。</p>
<blockquote>
<p><strong>求值三步法</strong>:</p>
<ol>
<li>对 <strong>运算符 (Operator)</strong> 求值，得到一个过程 。</li>
<li>从左到右对所有 <strong>操作数 (Operands)</strong> 求值，得到参数 。</li>
<li>将过程应用于参数 。</li>
</ol></blockquote>
<ul>
<li><strong>例</strong>：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>scm&gt; (- (+ <span style="color:#ae81ff">7</span> (* <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">6</span>)) (* <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">5</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e">; 1. (* 4 6) -&gt; 24</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">; 2. (+ 7 24) -&gt; 31</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">; 3. (* 3 5) -&gt; 15</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">; 4. (- 31 15) -&gt; 16</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">16</span>
</span></span></code></pre></div></li>
</ul>
<h4 id="3-特殊形式-special-forms">3. 特殊形式 (Special Forms)</h4>
<p>特殊形式的求值规则<strong>不同于</strong>标准的调用表达式，它们的运算符（如 <code>define</code>, <code>if</code>, <code>lambda</code>）<strong>不一定</strong>先求值，且操作数<strong>不一定</strong>全部求值 。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">特殊形式</th>
          <th style="text-align: left">英文标注</th>
          <th style="text-align: left">语法</th>
          <th style="text-align: left">求值规则</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>定义</strong></td>
          <td style="text-align: left"><strong>define</strong></td>
          <td style="text-align: left"><code>(define &lt;name&gt; &lt;expr&gt;)</code></td>
          <td style="text-align: left">1.  求值 <code>&lt;expr&gt;</code>  。 2. 将结果值绑定到当前框架的 <code>&lt;name&gt;</code> 上 。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>条件</strong></td>
          <td style="text-align: left"><strong>if</strong></td>
          <td style="text-align: left"><code>(if &lt;predicate&gt; &lt;if-true&gt; &lt;if-false&gt;)</code></td>
          <td style="text-align: left">1.  求值 <code>&lt;predicate&gt;</code>  。 2. <strong>如果结果不是 <code>#f</code></strong> (唯一 Falsy 值)  ，求值并返回 <code>&lt;if-true&gt;</code>  ；否则求值并返回 <code>&lt;if-false&gt;</code> 。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>过程</strong></td>
          <td style="text-align: left"><strong>lambda</strong></td>
          <td style="text-align: left"><code>(lambda (&lt;params&gt;) &lt;body&gt;)</code></td>
          <td style="text-align: left"><strong>创建并返回一个 lambda 过程 (Procedure)</strong>  。<strong>不求值</strong>函数体 <code>&lt;body&gt;</code>，函数体在过程被调用时才求值 。</td>
      </tr>
  </tbody>
</table>
<ul>
<li><strong><code>define</code> 简化形式 (Function Shorthand)</strong>:
<code>(define (square x) (* x x))</code> 等同于 <code>(define square (lambda (x) (* x x)))</code> 。</li>
</ul>
<hr>
<h2 id="主题二数据抽象pairs-与-lists-data-abstraction-pairs-and-lists">主题二：数据抽象：Pairs 与 Lists (Data Abstraction: Pairs and Lists)</h2>
<h3 id="主题概述-1">主题概述</h3>
<p>Scheme 中唯一的序列类型是<strong>链表 (Linked List)</strong>  。链表是通过基本的构建块<strong>对 (Pairs)</strong> 构成的 。</p>
<hr>
<h3 id="核心概念-core-concepts">核心概念 (Core Concepts)</h3>
<h4 id="1-对-pairs">1. 对 (Pairs)</h4>
<p>对是使用 <code>cons</code> 表达式创建的基本结构。</p>
<ul>
<li><strong><code>cons</code></strong>: 构造一个对 。
<ul>
<li><code>(cons &lt;first&gt; &lt;second&gt;)</code></li>
</ul>
</li>
<li><strong><code>car</code></strong>: 选择对中的<strong>第一个元素</strong> (Head) 。</li>
<li><strong><code>cdr</code></strong>: 选择对中的<strong>第二个元素</strong> (Tail) 。</li>
</ul>
<h4 id="2-链表-linked-lists">2. 链表 (Linked Lists)</h4>
<p>链表是通过递归地使用 <code>cons</code> 构造对，并以特殊符号 <code>nil</code> (空列表) 终止而形成的序列结构。</p>
<ul>
<li>
<p><strong><code>nil</code></strong>: 表示<strong>空列表 (Empty List)</strong> 。</p>
</li>
<li>
<p><strong>链表结构</strong>：第二个元素 (<code>cdr</code>) 必须是另一个对或 <code>nil</code> 。</p>
</li>
<li>
<p><strong>例题：链表构造</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>scm&gt; (cons <span style="color:#ae81ff">1</span> (cons <span style="color:#ae81ff">2</span> nil))
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>) <span style="color:#75715e">; 列表的表示形式</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>scm&gt; (<span style="color:#66d9ef">define </span>x (cons <span style="color:#ae81ff">1</span> (cons <span style="color:#ae81ff">2</span> nil)))
</span></span><span style="display:flex;"><span>scm&gt; (car x)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>scm&gt; (cdr x)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">2</span>) <span style="color:#75715e">; 结果仍然是一个列表 (一个对，其 car 是 2，cdr 是 nil)</span>
</span></span></code></pre></div></li>
</ul>
<hr>
<h2 id="主题三符号编程与引用-symbolic-programming-and-quotation">主题三：符号编程与引用 (Symbolic Programming and Quotation)</h2>
<h3 id="主题概述-2">主题概述</h3>
<p>在 Scheme 中，符号 (Symbols) 通常求值为其绑定的值。<strong>引用 (Quotation)</strong> 允许我们直接引用符号本身，而不是它的值 。这对于将 Scheme 代码结构作为数据处理（<strong>符号编程</strong>）至关重要。</p>
<hr>
<h3 id="核心概念-core-concepts-1">核心概念 (Core Concepts)</h3>
<h4 id="1-引用-quote-或-">1. 引用 (<code>quote</code> 或 <code>'</code>)</h4>
<ul>
<li>
<p><strong>作用</strong>: 阻止表达式被求值，而是将表达式本身作为值返回 。</p>
</li>
<li>
<p><strong>使用方式</strong>:</p>
<ul>
<li>长形式: <code>(quote &lt;expr&gt;)</code></li>
<li>短形式: <code>'&lt;expr&gt;</code></li>
</ul>
</li>
<li>
<p><strong>例题：引用符号</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>scm&gt; (<span style="color:#66d9ef">define </span>a <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>scm&gt; (list a <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>) <span style="color:#75715e">; a 被求值为 1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>scm&gt; (list <span style="color:#e6db74">&#39;a</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">a</span> <span style="color:#ae81ff">2</span>) <span style="color:#75715e">; &#39;a 被引用，求值为符号 a 本身</span>
</span></span></code></pre></div></li>
</ul>
<h4 id="2-引用组合-quoting-combinations">2. 引用组合 (Quoting Combinations)</h4>
<p>引用也可以应用于组合表达式，使其成为一个<strong>列表数据结构</strong>。</p>
<ul>
<li><strong>例题：引用列表</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>scm&gt; <span style="color:#f92672">&#39;</span>(a b c)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">a</span> b c) <span style="color:#75715e">; 返回列表 (a b c)</span>
</span></span><span style="display:flex;"><span>scm&gt; (car <span style="color:#f92672">&#39;</span>(a b c))
</span></span><span style="display:flex;"><span>a       <span style="color:#75715e">; car 选择列表的第一个元素</span>
</span></span><span style="display:flex;"><span>scm&gt; (cdr <span style="color:#f92672">&#39;</span>(a b c))
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">b</span> c)   <span style="color:#75715e">; cdr 选择列表的剩余部分</span>
</span></span></code></pre></div></li>
</ul>
<hr>
<h2 id="主题四尾递归-tail-recursion">主题四：尾递归 (Tail Recursion)</h2>
<h3 id="主题概述-3">主题概述</h3>
<p>Scheme 语言不内置迭代 (Iteration) 结构，循环通常通过<strong>递归 (Recursion)</strong> 实现 。<strong>尾递归 (Tail Recursion)</strong> 是一种特殊的递归形式，支持尾调用优化 (Tail Call Optimization)，能像迭代一样高效运行，使用<strong>常数 (Constant)</strong> 数量的帧 (Frames) 。</p>
<hr>
<h3 id="核心概念-1">核心概念</h3>
<h4 id="1-尾上下文与尾调用-tail-context-and-tail-call">1. 尾上下文与尾调用 (Tail Context and Tail Call)</h4>
<ul>
<li><strong>尾上下文 (Tail Context)</strong>: 表达式在尾上下文中，意味着它是在函数调用中求值的<strong>最后一步</strong>。在它求值/应用之后，<strong>没有其他操作</strong>会进行 。</li>
<li><strong>尾调用 (Tail Call)</strong>: 发生在尾上下文中的函数调用 。</li>
<li><strong>尾递归 (Tail Recursion)</strong>: 尾调用调用了<strong>函数自身</strong> 。</li>
</ul>
<h4 id="2-尾调用优化-tail-call-optimization-tco">2. 尾调用优化 (Tail Call Optimization, TCO)</h4>
<ul>
<li>如果 Scheme 语言支持 TCO，一个尾递归函数<strong>只会开启常数数量的帧</strong>，从而避免栈溢出，效率等同于迭代。</li>
</ul>
<h4 id="3-识别尾上下文-identifying-tail-contexts">3. 识别尾上下文 (Identifying Tail Contexts)</h4>
<ul>
<li>
<p><strong>是尾上下文 (Tail Contexts)</strong>:</p>
<ul>
<li><code>lambda</code>（函数）的<strong>最后一个 body 子表达式</strong>。</li>
<li><code>if</code> 中的 <code>&lt;if-true&gt;</code> 和 <code>&lt;if-false&gt;</code> (前提是 <code>if</code> 表达式本身在尾上下文中)。</li>
<li><code>and</code>, <code>or</code>, <code>begin</code>, <code>let</code> 中的<strong>最后一个子表达式</strong>。</li>
</ul>
</li>
<li>
<p><strong>不是尾上下文 (Non-Tail Contexts)</strong>:</p>
<ul>
<li>在 <code>*</code>, <code>+</code>, <code>-</code> 等操作符下作为<strong>操作数 (Operand)</strong> 的递归调用。因为操作数求值后，还需要进行操作符的运算。</li>
</ul>
</li>
<li>
<p><strong>例题：非尾递归阶乘 (Non-Tail Recursive Factorial)</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">fact</span> n)
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">if </span>(= n <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">#</span> 递归调用 (<span style="color:#a6e22e">fact</span> (- n <span style="color:#ae81ff">1</span>)) 的结果必须和 n 相乘
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">#</span> 因此 (<span style="color:#a6e22e">fact</span> <span style="color:#f92672">...</span>) 不在尾上下文<span style="color:#960050;background-color:#1e0010">，</span>需要保留帧 f1, f2, <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>      (* n (<span style="color:#a6e22e">fact</span> (- n <span style="color:#ae81ff">1</span>)))))
</span></span></code></pre></div></li>
</ul>
<h4 id="4-编写尾递归函数-writing-tail-recursive-functions">4. 编写尾递归函数 (Writing Tail Recursive Functions)</h4>
<p>要将非尾递归函数转换为尾递归，通常需要引入一个<strong>辅助函数 (Helper Function)</strong> 和一个<strong>累加器 (Accumulator)</strong> 参数。</p>
<ul>
<li>
<p><strong>目标</strong>: 将所有等待的计算（例如上面的 <code>* n</code>）作为参数，传递给下一次递归调用。</p>
</li>
<li>
<p><strong>累加器 (Accumulator)</strong>: 存储到目前为止的计算结果。</p>
</li>
<li>
<p><strong>例题：尾递归阶乘 (Tail Recursive Factorial)</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">fact</span> n)
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">#</span> 引入辅助函数 fact-tail
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">fact-tail</span> n result) <span style="color:#75715e">; result 就是累加器</span>
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">if </span>(&lt;= n <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        result
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">#</span> 最后一步操作是 (<span style="color:#a6e22e">fact-tail</span> <span style="color:#f92672">...</span>)<span style="color:#960050;background-color:#1e0010">，</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">#</span> 这是一个尾调用<span style="color:#960050;background-color:#1e0010">，</span>无需保留当前帧<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>        (<span style="color:#a6e22e">fact-tail</span> (- n <span style="color:#ae81ff">1</span>) (* n result)))) 
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">fact-tail</span> n <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">#</span> 初始调用<span style="color:#960050;background-color:#1e0010">，</span>累加器从 <span style="color:#ae81ff">1</span> 开始
</span></span></code></pre></div></li>
</ul>
<hr>
<h2 id="主题五表达式作为数据-expressions-as-data">主题五：表达式作为数据 (Expressions As Data)</h2>
<h3 id="主题概述-4">主题概述</h3>
<p>Scheme 的核心理念是<strong>代码即数据 (Code as Data)</strong>。由于 Scheme 表达式（组合）本身就是列表，我们可以将代码结构当作普通数据来操作。</p>
<h3 id="核心概念-2">核心概念</h3>
<h4 id="1-表达式的表示与求值-representation-and-evaluation">1. 表达式的表示与求值 (Representation and Evaluation)</h4>
<ul>
<li><strong>表达式的类型</strong>: 在 Scheme 中，表达式要么是<strong>原始表达式 (primitive expressions)</strong>，要么是<strong>列表 (lists)</strong>。</li>
<li><strong>引用 (Quoting)</strong>: <code>‘&lt;expr&gt;</code> 或 <code>(quote &lt;expr&gt;)</code> 阻止表达式求值，返回表达式本身（即一个数据结构）。</li>
<li><strong><code>eval</code> 函数</strong>: 接收一个<strong>未求值 (unevaluated)</strong> 的表达式（数据），并对其进行求值。</li>
<li><strong>例题</strong>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>scm&gt; <span style="color:#f92672">&#39;</span>(+ <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>) <span style="color:#75715e">; 引用，返回列表数据</span>
</span></span><span style="display:flex;"><span>(+ <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>scm&gt; (eval <span style="color:#f92672">&#39;</span>(+ <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>)) <span style="color:#75715e">; 对该列表进行求值</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span></code></pre></div><ul>
<li><strong>表达式的操作</strong>: 我们可以将表达式赋值给变量、作为参数传递给函数、甚至在函数内创建并返回新的表达式。</li>
</ul>
<hr>
<h2 id="主题六辅助特殊形式-auxiliary-special-forms">主题六：辅助特殊形式 (Auxiliary Special Forms)</h2>
<h3 id="主题概述-5">主题概述</h3>
<p><code>begin</code> 和 <code>let</code> 是 Scheme 中常用的特殊形式，用于控制求值顺序和局部变量的创建。</p>
<h3 id="核心概念-3">核心概念</h3>
<h4 id="1-begin-顺序执行">1. <code>begin</code> (顺序执行)</h4>
<ul>
<li><strong>作用</strong>: <code>begin</code> 接收任意数量的子表达式。它会按<strong>顺序 (in order)</strong> 求值这些子表达式，并以<strong>最后一个子表达式</strong>的值作为整个 <code>begin</code> 表达式的值。</li>
<li><strong>用途</strong>: 当你需要在一个预期只有一个表达式的位置（如函数体）执行多个带有副作用的操作时，<code>begin</code> 非常有用。</li>
<li><strong>例题</strong>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>scm&gt; (<span style="color:#66d9ef">begin </span>(<span style="color:#66d9ef">define </span>x <span style="color:#ae81ff">2</span>) (<span style="color:#66d9ef">define </span>x (+ x <span style="color:#ae81ff">1</span>)) x)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span> <span style="color:#75715e">; 返回最后一个表达式 x 的值</span>
</span></span></code></pre></div><h4 id="2-let-局部绑定">2. <code>let</code> (局部绑定)</h4>
<ul>
<li><strong>作用</strong>: <code>let</code> 用于创建<strong>临时</strong>的局部变量绑定，仅在 <code>let</code> 的主体 (<code>body</code>) 中有效。</li>
<li><strong>绑定规则</strong>: 所有的 <code>symbol</code> 都与其对应的 <code>expr</code> 的值<strong>并行 (in parallel)</strong> 绑定。这意味着一个绑定不能引用同一 <code>let</code> 表达式中定义的其他绑定。</li>
<li><strong>语法</strong>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">let </span>((<span style="color:#a6e22e">symbol1</span> expr1)
</span></span><span style="display:flex;"><span>      (<span style="color:#a6e22e">symbol2</span> expr2)
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>  &lt;body&gt;)
</span></span></code></pre></div><hr>
<h2 id="主题七宏原理-macro-principles">主题七：宏原理 (Macro Principles)</h2>
<h3 id="主题概述-6">主题概述</h3>
<p>宏 (Macros) 是一种<strong>元编程 (Metaprogramming)</strong> 工具，它允许用户在程序<strong>求值之前</strong>转换程序的代码结构，从而扩展语言的语法。</p>
<h3 id="核心概念-4">核心概念</h3>
<h4 id="1-定义宏-define-macro">1. 定义宏 (<code>define-macro</code>)</h4>
<ul>
<li><strong>语法</strong>: <code>(define-macro (&lt;name&gt; &lt;params&gt;) &lt;body&gt;)</code>。</li>
<li><strong>宏与过程的区别</strong>:</li>
<li><strong>过程 (Procedure)</strong>: 接收<strong>值 (values)</strong> 作为参数，返回<strong>值</strong>。</li>
<li><strong>宏 (Macro)</strong>: 接收<strong>表达式 (expressions)</strong> 作为参数，返回<strong>表达式</strong>（代码）。</li>
</ul>
<h4 id="2-宏的求值流程-macro-evaluation-核心考点">2. 宏的求值流程 (Macro Evaluation) <strong>【核心考点】</strong></h4>
<p>宏调用的求值流程有别于普通函数调用：</p>
<ol>
<li><strong>不求值操作数 (Operands Not Evaluated)</strong>: 宏的操作数<strong>不会</strong>像普通函数调用那样被求值。</li>
<li><strong>传递表达式</strong>: 操作数（表达式本身）作为参数传递给宏过程。</li>
<li><strong>宏转换</strong>: 宏过程执行，返回一个新的<strong>表达式 (a new expression)</strong>。</li>
<li><strong>再次求值</strong>: 解释器会立即对宏返回的<strong>新表达式</strong>进行<strong>求值 (evaluated)</strong>。</li>
</ol>
<h4 id="3-宏的用途-writing-macros">3. 宏的用途 (Writing Macros)</h4>
<p>编写宏时，关键是思考<strong>具有等效行为的表达式是什么</strong>。宏的目的是将自定义的语法转换为等效的 Scheme 基本语法。</p>
<ul>
<li><strong>例题：<code>for</code> 宏</strong>: 转换 <code>(for x in '(1 2 3 4) do (* x x))</code> 为 <code>(map (lambda (x) (* x x)) '(1 2 3 4))</code>。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">define-macro</span> (<span style="color:#a6e22e">for</span> sym in vals <span style="color:#66d9ef">do </span>expr)
</span></span><span style="display:flex;"><span>  (list <span style="color:#e6db74">&#39;map</span> (list <span style="color:#e6db74">&#39;lambda</span> (list sym) expr) vals))
</span></span></code></pre></div><hr>
<h2 id="主题八准引用-quasi-quotation">主题八：准引用 (Quasi-Quotation)</h2>
<h3 id="主题概述-7">主题概述</h3>
<p>在宏中，我们经常需要构造新的列表（表达式）。<strong>准引用 (Quasi-Quotation)</strong> 允许在引用 (Quoting) 表达式的同时，有选择地对其中的部分子表达式进行求值，大大简化了代码生成。</p>
<h3 id="核心概念-5">核心概念</h3>
<table>
  <thead>
      <tr>
          <th>符号</th>
          <th>英文标注</th>
          <th>名称</th>
          <th>作用</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>```</td>
          <td><strong>Quasiquote</strong></td>
          <td><strong>准引用</strong></td>
          <td>允许列表中的大部分内容被视为字面值（像 <code>quote</code> 一样）。</td>
      </tr>
      <tr>
          <td><code>,</code></td>
          <td><strong>Unquote</strong></td>
          <td><strong>取消引用</strong></td>
          <td>必须出现在准引用 ```` 内部。紧跟其后的表达式会被<strong>求值</strong>，然后将其值插入到构造的列表中。</td>
      </tr>
  </tbody>
</table>
<ul>
<li><strong>例题：使用准引用重写 <code>for</code> 宏</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">define-macro</span> (<span style="color:#a6e22e">for</span> sym vals expr)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">; 整个结构是准引用的 (`)，大部分是字面值</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">; ,sym, ,expr, ,vals 在宏应用时会被求值并替换到相应位置</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>(map (<span style="color:#66d9ef">lambda </span>(<span style="color:#f92672">,</span>sym) <span style="color:#f92672">,</span>expr) <span style="color:#f92672">,</span>vals)) 
</span></span></code></pre></div><ul>
<li><strong><code>(</code></strong> 和 <strong><code>map</code></strong> 是字面符号。</li>
<li><strong><code>,sym</code></strong> 求值结果是符号 <code>x</code>，被插入到 <code>lambda</code> 的参数列表中。</li>
<li><strong><code>,expr</code></strong> 求值结果是表达式 <code>(* x x)</code>，被插入到 <code>lambda</code> 的函数体中。</li>
<li><strong><code>,vals</code></strong> 求值结果是表达式 <code>'(1 2 3 4)</code>，被插入到 <code>map</code> 的第二个参数位置。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>函数1:twice
</span></span><span style="display:flex;"><span>方式1:正常函数
</span></span><span style="display:flex;"><span>scm&gt; (<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">twice</span> exp) (list <span style="color:#e6db74">&#39;begin</span> exp exp))
</span></span><span style="display:flex;"><span>twice
</span></span><span style="display:flex;"><span>scm&gt; (eval (<span style="color:#a6e22e">twice</span> <span style="color:#f92672">&#39;</span>(print <span style="color:#ae81ff">2</span>)))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>方式2:macro
</span></span><span style="display:flex;"><span>scm&gt; (<span style="color:#a6e22e">define-macro</span> (<span style="color:#a6e22e">twice</span> exp) (list <span style="color:#e6db74">&#39;begin</span> exp exp))
</span></span><span style="display:flex;"><span>twice
</span></span><span style="display:flex;"><span>scm&gt; (<span style="color:#a6e22e">twice</span> (<span style="color:#a6e22e">print</span> <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>即macro只是相当于省略了调用时需要的eval 和<span style="color:#f92672">&#39;</span>
</span></span><span style="display:flex;"><span>方式3:准引用(<span style="color:#a6e22e">suger</span>)
</span></span><span style="display:flex;"><span>scm&gt; (<span style="color:#a6e22e">define-macro</span> (<span style="color:#a6e22e">twice</span> exp) <span style="color:#f92672">`</span>(<span style="color:#66d9ef">begin </span><span style="color:#f92672">,</span>exp <span style="color:#f92672">,</span>exp))
</span></span><span style="display:flex;"><span>twice
</span></span><span style="display:flex;"><span>scm&gt; (<span style="color:#a6e22e">twice</span> (<span style="color:#a6e22e">print</span> <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>函数2
</span></span><span style="display:flex;"><span>scm&gt; (<span style="color:#a6e22e">define-macro</span> (<span style="color:#a6e22e">add-to</span> sym exp) (list <span style="color:#e6db74">&#39;define</span> sym (list <span style="color:#e6db74">&#39;+</span> sym exp)))
</span></span><span style="display:flex;"><span>add-to
</span></span><span style="display:flex;"><span>scm&gt; (<span style="color:#a6e22e">add-to</span> <span style="color:#e6db74">&#39;x</span> (+ x <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>x
</span></span><span style="display:flex;"><span>scm&gt; x
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">30</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>scm&gt; (<span style="color:#a6e22e">define-macro</span> (<span style="color:#a6e22e">add-to</span> sym exp) <span style="color:#f92672">`</span>(<span style="color:#66d9ef">define </span><span style="color:#f92672">,</span>sym (+ <span style="color:#f92672">,</span>sym <span style="color:#f92672">,</span>exp)))
</span></span><span style="display:flex;"><span>add-to
</span></span><span style="display:flex;"><span>scm&gt; (<span style="color:#a6e22e">add-to</span> x (+ x <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>x
</span></span><span style="display:flex;"><span>scm&gt; x
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">62</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>函数3
</span></span><span style="display:flex;"><span>scm&gt; (<span style="color:#a6e22e">define-macro</span> (<span style="color:#a6e22e">for</span> sym in val <span style="color:#66d9ef">do </span>exp) <span style="color:#f92672">`</span>(map (<span style="color:#66d9ef">lambda </span>(<span style="color:#f92672">,</span>sym) <span style="color:#f92672">,</span>exp) <span style="color:#f92672">,</span>val))
</span></span><span style="display:flex;"><span>for
</span></span><span style="display:flex;"><span>scm&gt; (<span style="color:#a6e22e">for</span> i in (list <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span>) <span style="color:#66d9ef">do </span>(<span style="color:#a6e22e">print</span> i))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">undefined</span> undefined undefined)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">上面这行是map的返回值,即None,None,None</span>)
</span></span></code></pre></div><hr>
<h2 id="主题九惰性求值与流基础-lazy-evaluation--stream-basics">主题九：惰性求值与流基础 (Lazy Evaluation &amp; Stream Basics)</h2>
<h3 id="主题概述-8">主题概述</h3>
<p><strong>流 (Streams)</strong> 是 Scheme 中处理序列的一种方式。它与链表（List）非常相似，但核心区别在于：流的“剩余部分”（tail）只有在被显式要求时才会进行计算。这种机制被称为<strong>惰性求值 (Lazy Evaluation)</strong>。</p>
<h3 id="核心概念-6">核心概念</h3>
<h4 id="1-为什么需要流">1. 为什么需要流？</h4>
<ul>
<li><strong>Python 对比</strong>: Python 使用迭代器（Iterators）和生成器（Generators）来实现惰性求值，可以表示无限序列。</li>
<li><strong>Scheme 链表的局限</strong>: 在标准链表中，<code>cons</code> 的第二个参数总是会被立即求值。如果尝试递归定义无限链表，会导致 <code>maximum recursion depth exceeded</code>（达到最大递归深度）。</li>
<li><strong>流的优势</strong>: 流允许我们表示巨大的甚至<strong>无限长 (infinitely long)</strong> 的列表，因为它只在需要时计算下一个元素。</li>
</ul>
<h4 id="2-流的构造与基本操作">2. 流的构造与基本操作</h4>
<ul>
<li><strong><code>cons-stream</code></strong>: 构造一个流。其第二个参数是一个<strong>承诺 (Promise)</strong>，不会立即求值。</li>
<li><strong><code>car</code></strong>: 获取流的第一个元素（与 List 相同）。</li>
<li><strong><code>cdr-stream</code></strong>: 获取流的剩余部分。这是关键操作：它会<strong>强制 (Force)</strong> 履行承诺，计算并返回流的下一个部分。</li>
<li><strong>例题：流的表示</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>scm&gt; (<span style="color:#66d9ef">define </span>s (<span style="color:#a6e22e">cons-stream</span> <span style="color:#ae81ff">1</span> (<span style="color:#a6e22e">cons-stream</span> <span style="color:#ae81ff">2</span> nil)))
</span></span><span style="display:flex;"><span>s
</span></span><span style="display:flex;"><span>scm&gt; s
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">.</span> <span style="color:#f92672">#</span>[promise (not forced)])  <span style="color:#75715e">; 第二部分显示为尚未强制的承诺</span>
</span></span><span style="display:flex;"><span>scm&gt; (car s)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>scm&gt; (<span style="color:#a6e22e">cdr-stream</span> s)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">2</span> <span style="color:#f92672">.</span> <span style="color:#f92672">#</span>[promise (not forced)])
</span></span></code></pre></div><hr>
<h2 id="主题十一无限流-infinite-streams">主题十一：无限流 (Infinite Streams)</h2>
<h3 id="主题概述-9">主题概述</h3>
<p>由于流是惰性求值的，我们可以定义一个在逻辑上永远不会结束的序列。</p>
<h3 id="核心概念-7">核心概念</h3>
<h4 id="1-定义无限流">1. 定义无限流</h4>
<p>通过在 <code>cons-stream</code> 的第二个参数中进行递归调用，可以创建一个无限序列。</p>
<ul>
<li><strong>例题：整数流 (Integer Stream)</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">ints</span> first)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">cons-stream</span> first (<span style="color:#a6e22e">ints</span> (+ first <span style="color:#ae81ff">1</span>))))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>scm&gt; (<span style="color:#66d9ef">define </span>s (<span style="color:#a6e22e">ints</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>scm&gt; (car s)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>scm&gt; (car (<span style="color:#a6e22e">cdr-stream</span> s))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span></code></pre></div><h4 id="2-使用高阶函数操作流">2. 使用高阶函数操作流</h4>
<p>我们可以像操作 List 一样编写流的操作函数，只需将 <code>cons</code> 替换为 <code>cons-stream</code>，将 <code>cdr</code> 替换为 <code>cdr-stream</code>。</p>
<ul>
<li><strong><code>map-stream</code> (流映射)</strong>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">map-stream</span> fn s)
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">if </span>(null? s)
</span></span><span style="display:flex;"><span>      nil
</span></span><span style="display:flex;"><span>      (<span style="color:#a6e22e">cons-stream</span> (<span style="color:#a6e22e">fn</span> (car s))
</span></span><span style="display:flex;"><span>                   (<span style="color:#a6e22e">map-stream</span> fn (<span style="color:#a6e22e">cdr-stream</span> s)))))
</span></span></code></pre></div><ul>
<li><strong><code>filter-stream</code> (流过滤)</strong>:
只有当满足条件的元素被找到时，才会构造流的下一个 <code>car</code>。</li>
</ul>
<hr>
<h2 id="主题十二流的高级应用-advanced-stream-applications">主题十二：流的高级应用 (Advanced Stream Applications)</h2>
<h3 id="核心概念-core-concepts-2">核心概念 (Core Concepts)</h3>
<h4 id="1-递归定义的流-self-referencing-streams">1. 递归定义的流 (Self-referencing Streams)</h4>
<p>流可以引用自身来定义复杂的序列。</p>
<ul>
<li><strong>全 1 流 (Ones)</strong>: <code>(define ones (cons-stream 1 ones))</code></li>
<li><strong>整数流 (Integers)</strong>:
通过将“全 1 流”与“当前整数流”相加得到下一个整数。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>ones (<span style="color:#a6e22e">cons-stream</span> <span style="color:#ae81ff">1</span> ones))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>ints (<span style="color:#a6e22e">cons-stream</span> <span style="color:#ae81ff">1</span> (<span style="color:#a6e22e">add-stream</span> ones ints)))
</span></span></code></pre></div><h4 id="2-流与列表的转换">2. 流与列表的转换</h4>
<ul>
<li><strong><code>stream-to-list</code></strong>: 为了查看流的内容，通常需要将其转换为列表，并指定获取元素的数量（避免死循环）。</li>
</ul></section>

  
  
  <div class="paginator">
    
    <a class="prev" href="https://cloudymount789.github.io/blog/sicp_note_sql/">
      <svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375C21.4339 3.93962 21.3581 3.30535 21.1917 2.76787M3.77086 21.1546C1.9934 20.7777 0.973585 18.7264 1.08749 16.688C1.2668 13.479 1.15721 9.43135 1.00513 6.21507C0.87809 3.52811 3.12891 1.16316 5.51029 1.25008C9.76594 1.40542 15.377 1.20229 18.7912 1.00542C20.0864 0.930734 20.8406 1.63385 21.1917 2.76787M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787C23.1097 4.18217 23.13 12.4191 22.9004 16.3608C20.8478 24.0194 12.3061 23.6662 6.5 22.0658M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608C21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966C5.98257 11.8297 5.98456 11.9753 6.05061 12.0063C7.05496 12.4779 8.92941 13.9264 9.94496 15M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentColor" stroke-linecap="round"/>
      </svg>
      <span>SICP_SQL_笔记</span></a>
    
    
    <a class="next" href="https://cloudymount789.github.io/blog/sicp_note_after_mid/"><span>SICP_python_期中后笔记</span>
      <svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375C21.4339 3.93962 21.3581 3.30535 21.1917 2.76787M3.77086 21.1546C1.9934 20.7777 0.973585 18.7264 1.08749 16.688C1.2668 13.479 1.15721 9.43135 1.00513 6.21507C0.87809 3.52811 3.12891 1.16316 5.51029 1.25008C9.76594 1.40542 15.377 1.20229 18.7912 1.00542C20.0864 0.930734 20.8406 1.63385 21.1917 2.76787M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787C23.1097 4.18217 23.13 12.4191 22.9004 16.3608C20.8478 24.0194 12.3061 23.6662 6.5 22.0658M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608C21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966C16.0174 11.8297 16.0154 11.9753 15.9494 12.0063C14.945 12.4779 13.0706 13.9264 12.055 15M15.5556 11.9667C13.1345 12.0608 8 12 6 11" stroke="currentColor" stroke-linecap="round"/>
      </svg>
    </a>
    
  </div>
  

  


  
  
</article>


        </div><footer class="footer">
  <p>&copy; 2026 <a href="https://cloudymount789.github.io/">CloudyMount</a>
    Powered by
    <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>
    <a href="https://github.com/guangzhengli/hugo-theme-ladder" rel="noopener" target="_blank">Ladder</a>
️  </p>
</footer>

<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211C22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257M21.7387 7.71865C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257C17.1684 -1.24629 7.83127 0.632493 4.27577 5.04257C2.88063 6.77451 -0.0433281 11.1668 1.38159 16.6571C2.27481 20.0988 5.17269 22.2936 8.19743 22.7725M20.7188 5.04257C22.0697 6.9404 24.0299 11.3848 22.3541 15.4153M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814C11.1703 6.98257 11.0247 6.98456 10.9937 7.05061C10.5221 8.05496 9.07362 9.92941 8 10.945M11.0333 7.44444C10.9392 9.86549 11 15 12 17" stroke="currentColor" stroke-linecap="round"/>
    </svg>
</a>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>

<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Copied';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });
        codeblock.parentNode.appendChild(copybutton);
    });
</script></main>
    </body>
  
  <script src="/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js" integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin="anonymous" defer></script></html>
